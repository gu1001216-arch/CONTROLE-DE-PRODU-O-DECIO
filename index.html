<!DOCTYPE html>
<html lang="pt-br">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Controle de Produção - Turno 1 (Ciclos até 17:30)</title>
    <style>
        body {
            font-family: Arial, sans-serif;
            background-color: #f4f4f4;
            color: #333;
            margin: 0;
            padding: 0;
        }
        header {
            background-color: #2c3e50;
            color: white;
            padding: 10px 0;
            text-align: center;
        }
        .content {
            padding: 20px;
            text-align: center;
        }
        
        /* Container para Relógio, Dashboard e Contagem Regressiva */
        .header-display {
            display: flex;
            justify-content: center;
            align-items: center;
            gap: 20px;
            margin-bottom: 20px;
        }
        
        .relogio-box, .countdown-box, .ciclos-completos-box, .ciclos-nao-completos-box {
            display: inline-block;
            padding: 15px 25px;
            border-radius: 8px;
            font-weight: bold;
            box-shadow: 0px 4px 8px rgba(0, 0, 0, 0.2);
            transition: background-color 0.3s;
            text-align: center;
        }
        
        .relogio-box {
            background-color: #ecf0f1;
            font-size: 30px;
        }

        .ciclos-completos-box {
            background-color: #d1e7dd; 
            border: 2px solid #28a745;
            font-size: 20px;
            color: #2c3e50;
        }

        /* NOVO ESTILO: Dashboard de Ciclos Não Concluídos */
        .ciclos-nao-completos-box {
            background-color: #f8d7da; /* Cor de fundo suave para alerta */
            border: 2px solid #e74c3c; /* Borda Vermelha */
            font-size: 20px;
            color: #2c3e50;
        }
        
        .countdown-box {
            background-color: #f0f8ff;
            border: 2px solid #2c3e50;
            font-size: 20px;
            color: #2c3e50;
            text-align: left;
        }
        .display-value {
            display: block; 
            font-size: 1.5em; 
            margin-top: 5px;
        }
        
        /* NOVO ESTILO: Container para o Seletor de Produtos e Botão Fullscreen */
        .product-selector-container {
            display: flex;
            justify-content: center;
            align-items: center;
            gap: 15px;
            margin-bottom: 20px;
        }
        
        #product-select {
            padding: 10px 15px;
            font-size: 16px;
            border-radius: 5px;
            border: 1px solid #ccc;
        }
        
        #fullscreenToggle {
            padding: 10px 15px;
            font-size: 16px;
            font-weight: bold;
            background-color: #3498db; /* Azul */
            color: white;
            border: none;
            border-radius: 5px;
            cursor: pointer;
            transition: background-color 0.3s;
        }
        #fullscreenToggle:hover {
            background-color: #2980b9;
        }


        /* Estilos do novo relatório vertical */
        .log-container {
            width: 100%;
            max-width: 800px; /* Limite a largura para melhor visualização */
            margin: 0 auto;
            overflow-x: auto;
            max-height: 50vh; /* Permite rolagem vertical no corpo da tabela */
            overflow-y: scroll;
            border: 1px solid #ccc;
        }
        
        .production-log {
            width: 100%;
            border-collapse: collapse;
            table-layout: fixed; /* Ajuda a fixar a largura das colunas */
        }

        .production-log thead {
            position: sticky; /* Congela o cabeçalho no topo */
            top: 0;
            background-color: #2c3e50;
            color: white;
            z-index: 10;
        }
        
        .production-log th, .production-log td {
            padding: 8px;
            border: 1px solid #ddd;
            text-align: center;
            vertical-align: middle;
        }

        /* Largura das colunas (Ciclo, Horário, Status, Observações) */
        .production-log th:nth-child(1) { width: 15%; } /* Ciclo # */
        .production-log th:nth-child(2) { width: 25%; } /* Horário Final */ 
        .production-log th:nth-child(3) { width: 20%; } /* Status */
        .production-log th:nth-child(4) { width: 40%; } /* Observações */

        .production-log tbody tr:nth-child(even) {
            background-color: #f9f9f9;
        }
        
        .production-log input[type="time"] {
            font-size: 16px;
            padding: 3px;
            width: 110px; /* Aumentado para acomodar HH:MM:SS */
            text-align: center;
            border: none;
            background-color: transparent;
            font-weight: bold;
        }
        
        /* Campo de Observação */
        .observation-input {
            width: 95%;
            padding: 5px;
            border: 1px solid #ccc;
            border-radius: 3px;
            box-sizing: border-box;
            font-size: 14px;
        }
        
        /* Estilos para o Status */
        .status-celula {
            display: block; /* Garante que o texto fique em uma linha separada do checkbox */
            font-weight: bold;
            margin-top: 5px;
        }
        
        .status-concluido {
            color: #28a745; /* Verde */
        }
        /* NOVO ESTILO: Status Não Concluído */
        .status-nao-concluido {
            color: #e74c3c; /* Vermelho */
        }
        .status-andamento {
            font-weight: bold;
            color: #ffc107; /* Amarelo/Laranja */
        }


        .tact-time-info {
            font-size: 1.2em;
            font-weight: bold;
            color: #2c3e50;
            margin-bottom: 15px;
        }
        /* Estilo para o novo botão de início */
        #iniciarSistema {
            padding: 15px 30px; 
            font-size: 20px; 
            font-weight: bold;
            background-color: #2ecc71; /* Verde */
            color: white;
            border: none;
            border-radius: 5px;
            cursor: pointer;
            transition: background-color 0.3s;
            margin-bottom: 20px;
        }
        #iniciarSistema:hover {
            background-color: #27ae60;
        }
        /* Estilos para os novos botões de controle de linha */
        .controle-linha {
            margin-bottom: 20px;
        }
        #pararLinha, #continuarLinha {
            padding: 15px 30px; 
            font-size: 20px; 
            font-weight: bold;
            border: none;
            border-radius: 5px;
            cursor: pointer;
            transition: background-color 0.3s;
        }
        #pararLinha {
            background-color: #e74c3c; /* Vermelho */
            color: white;
            margin-right: 10px;
        }
        #continuarLinha {
            background-color: #3498db; /* Azul */
            color: white;
        }
        /* Estilo para o botão de exportar/reset */
        #exportarRelatorio, #resetarObservacoes {
            padding: 10px 20px; 
            font-size: 16px; 
            font-weight: bold;
            color: white;
            border: none;
            border-radius: 5px;
            cursor: pointer;
            transition: background-color 0.3s;
        }
        #exportarRelatorio {
            background-color: #007bff; /* Azul */
        }
        #exportarRelatorio:hover {
            background-color: #0056b3;
        }
        #resetarObservacoes {
            background-color: #f39c12; /* Laranja */
        }
        #resetarObservacoes:hover {
            background-color: #e67e22;
        }
        
        /* ------------------------------------------------------------- */
        /* NOVO ESTILO: MODO DASHBOARD TELA CHEIA (FULLSCREEN) */
        /* ------------------------------------------------------------- */
        .fullscreen-overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: #2c3e50; /* Cor de fundo escura */
            z-index: 1000;
            display: none; /* Inicia oculto */
            flex-direction: column;
            justify-content: center;
            align-items: center;
            color: white;
        }
        
        .fullscreen-overlay.active {
            display: flex;
        }

        .fs-header-display {
            display: flex;
            flex-direction: column;
            gap: 20px;
            width: 90%;
            max-width: 1200px;
            margin-bottom: 50px;
        }
        
        .fs-row-1, .fs-row-2 {
            display: flex;
            justify-content: space-between;
            width: 100%;
        }

        .fs-relogio-box, .fs-countdown-box, .fs-ciclos-completos-box, .fs-ciclos-nao-completos-box {
            flex: 1;
            padding: 30px 40px;
            border-radius: 12px;
            font-weight: bold;
            box-shadow: 0px 4px 15px rgba(0, 0, 0, 0.4);
            text-align: center;
            margin: 0 10px;
            min-width: 200px;
            max-width: 400px;
        }

        .fs-relogio-box {
            background-color: #ecf0f1;
            font-size: 50px;
            color: #2c3e50;
        }
        
        .fs-ciclos-completos-box {
            background-color: #2ecc71; /* Verde forte */
            font-size: 30px;
            color: white;
        }

        .fs-ciclos-nao-completos-box {
            background-color: #e74c3c; /* Vermelho forte */
            font-size: 30px;
            color: white;
        }
        
        .fs-countdown-box {
            background-color: #3498db; /* Azul forte */
            font-size: 30px;
            color: white;
            text-align: center;
        }
        
        .fs-display-value {
            display: block; 
            font-size: 2.5em; 
            margin-top: 10px;
        }
        
        #fs-close-button {
            position: absolute;
            top: 20px;
            right: 20px;
            background: none;
            border: 2px solid white;
            color: white;
            padding: 10px 20px;
            font-size: 18px;
            cursor: pointer;
            border-radius: 5px;
            transition: background-color 0.3s;
        }
        #fs-close-button:hover {
            background-color: rgba(255, 255, 255, 0.1);
        }

        .fs-current-product-info {
            font-size: 2.5em;
            font-weight: bold;
            margin-top: -30px; 
            margin-bottom: 30px;
            width: 90%;
            max-width: 1200px;
            text-align: left;
        }

    </style>
</head>
<body>

<header>
    <h1>Cadenciador de Produtividade 1° Turno</h1>
</header>

<div class="content">
    
    <div class="header-display">
        <div class="relogio-box" id="relogio">
            Carregando horário...
        </div>
        
        <div class="ciclos-completos-box" id="ciclosCompletos">
            <strong>Ciclos Concluídos:</strong>
            <span class="display-value" style="color: #28a745;">0</span>
        </div>

        <div class="ciclos-nao-completos-box" id="ciclosNaoCompletos">
            <strong>Ciclos Não Concluídos:</strong>
            <span class="display-value" style="color: #e74c3c;">0</span>
        </div>
        
        <div class="countdown-box" id="countdown">
            <strong>Próximo Evento:</strong>
            <span class="display-value" style="color: #3498db;">--:--:--</span>
        </div>
    </div>

    <button id="iniciarSistema">
        CLIQUE AQUI PARA INICIAR O SISTEMA DE AVISOS DE VOZ E MANTER A TELA ATIVA
    </button>
    
    <div class="controle-linha">
        <button id="pararLinha" style="display: none;">
            PARAR LINHA
        </button>
        <button id="continuarLinha" style="display: none;">
            CONTINUAR LINHA
        </button>
    </div>
    
    <div class="product-selector-container">
        <select id="product-select" onchange="trocarAba(this.value)">
            </select>
        <button id="fullscreenToggle" onclick="toggleFullscreenDashboard()" style="display: none;">
            DASHBOARD TELA CHEIA
        </button>
    </div>
    
    <div style="margin-bottom: 20px;">
        <button id="exportarRelatorio" onclick="exportarParaExcel()" style="display: none; margin-right: 10px;">
            EXPORTAR RELATÓRIO PARA EXCEL
        </button>
        <button id="resetarObservacoes" style="display: none;">
            RESETAR OBSERVAÇÕES
        </button>
    </div>

    <div id="product-content">
        </div>

</div>

<div id="fullscreenDashboard" class="fullscreen-overlay">
    
    <div class="fs-current-product-info" id="fs-product-info">
        Produto Ativo: N/A (Takt Time: N/A)
    </div>
    
    <div class="fs-header-display">
        <div class="fs-row-1">
            <div class="fs-relogio-box" id="fs-relogio">
                Carregando...
            </div>
            
            <div class="fs-countdown-box" id="fs-countdown">
                <strong>Próximo Evento:</strong>
                <span class="fs-display-value">--:--:--</span>
            </div>
        </div>
        
        <div class="fs-row-2">
            <div class="fs-ciclos-completos-box" id="fs-ciclosCompletos">
                <strong>Ciclos Concluídos:</strong>
                <span class="fs-display-value">0</span>
            </div>

            <div class="fs-ciclos-nao-completos-box" id="fs-ciclosNaoCompletos">
                <strong>Ciclos Não Concluídos:</strong>
                <span class="fs-display-value">0</span>
            </div>
        </div>
    </div>

    <button id="fs-close-button" onclick="toggleFullscreenDashboard()">
        SAIR DO DASHBOARD
    </button>
</div>


<script>
    // -----------------------------------------------------------------------------------
    // DADOS FIXOS E ESTADO GLOBAL
    // -----------------------------------------------------------------------------------

    const TURNO_INICIO = '06:00:00';
    const TURNO_FIM = '17:30:00'; // Finalização do turno
    const TURNO_FIM_SEGUNDOS = 63000; // 17:30:00 em segundos

    // Avisos de voz para o início dos intervalos
    const INTERVALOS = [
        { inicio: '08:20:00', fim: '08:35:00', nome: 'Café 1', avisoVoz: 'Intervalo iniciado, bom café a todos!' },
        { inicio: '11:30:00', fim: '12:30:00', nome: 'Almoço', avisoVoz: 'Intervalo iniciado, bom almoço a todos!' },
        { inicio: '13:50:00', fim: '14:05:00', nome: 'Café 2', avisoVoz: 'Intervalo iniciado, bom café a todos!' },
    ];

    const PRODUTOS = [
        // Lista completa de produtos e seus Tact Times em minutos
        { nome: 'PATCH PANEL PPD24', tactTime: 3 },
        { nome: 'PATCH PANEL PPDB24', tactTime: 4 },
        { nome: 'RACK MRD 3U 470MM', tactTime: 10 },
        { nome: 'RACK MRD 5U 470MM', tactTime: 10 },
        { nome: 'RACK MRD 8U 470MM', tactTime: 11 },
        { nome: 'RACK MRD 12U 470MM', tactTime: 11.5 },
        { nome: 'RACK MRD 3U BS', tactTime: 10 },
        { nome: 'RACK MRD 5U BS', tactTime: 10 },
        { nome: 'RACK MRD 8U BS', tactTime: 11 },
        { nome: 'RACK MRD 12U BS', tactTime: 11.5 },
        { nome: 'RACK 5U BS OUTDOOR', tactTime: 4 },
        { nome: 'RACK 8U BS OUTDOOR', tactTime: 5 },
        { nome: 'RACK 12U BS OUTDOOR', tactTime: 5 },
        { nome: 'RACK 24U TORRE', tactTime: 2 },
        { nome: 'RACK 36U TORRE', tactTime: 4 },
        { nome: 'RACK 44U TORRE', tactTime: 2 },
        { nome: 'RACK RPD PA 1657', tactTime: 4 },
        { nome: 'RACK RPD PA 2057', tactTime: 4 },
        { nome: 'RACK RPD PA 2457', tactTime: 2 },
        { nome: 'RACK RPD PA 2857', tactTime: 5 },
        { nome: 'RACK RPD PA 3257', tactTime: 5 },
        { nome: 'RACK RPD PA 3657', tactTime: 2 },
        { nome: 'RACK RPD PA 4057', tactTime: 4 },
        { nome: 'RACK RPD PA 4457', tactTime: 2 },
        { nome: 'RACK RPD PP 4457', tactTime: 5 },
        { nome: 'RACK RPD PA 1667', tactTime: 4 },
        { nome: 'RACK RPD PA 2067', tactTime: 2 },
        { nome: 'RACK RPD PA 2467', tactTime: 5 },
        { nome: 'RACK RPD PA 2867', tactTime: 4 },
        { nome: 'RACK RPD PA 3267', tactTime: 4 },
        { nome: 'RACK RPD PA 3667', tactTime: 3 },
        { nome: 'RACK RPD PA 4067', tactTime: 2 },
        { nome: 'RACK RPD PA 4467', tactTime: 2 },
        { nome: 'RACK RPD PP 4467', tactTime: 2 },
        { nome: 'RACK RPD PA 2487', tactTime: 3 },
        { nome: 'RACK RPD PA 2887', tactTime: 3 },
        { nome: 'RACK RPD PA 3287', tactTime: 2 },
        { nome: 'RACK RPD PA 3687', tactTime: 4 },
        { nome: 'RACK RPD PA 4087', tactTime: 3 },
        { nome: 'RACK RPD PA 4487', tactTime: 5 },
        { nome: 'RACK RPD PP 4487', tactTime: 2 },
        { nome: 'RACK RPD PA 3217', tactTime: 4 },
        { nome: 'RACK RPD PA 3617', tactTime: 2 },
        { nome: 'RACK RPD PA 4017', tactTime: 4 },
        { nome: 'RACK RPD PA 4417', tactTime: 3 },
        { nome: 'RACK RPD PP 4417', tactTime: 2 },
        { nome: 'ORG CABOS VERTICAL 36U', tactTime: 2 },
        { nome: 'ORG CABOS VERTICAL 44U', tactTime: 4 },
        { nome: 'RACK ESTRUTURA RPD-4495', tactTime: 4 },
        { nome: 'ENTERPRISE 44U (FECHADO)', tactTime: 2 },
        { nome: 'ENTERPRISE 44U (ABERTO)', tactTime: 3 },
        { nome: 'L 800', tactTime: 5 },
        { nome: 'L 600', tactTime: 2 },
        { nome: 'L 400', tactTime: 4 },
        { nome: 'L 290', tactTime: 4 },
        { nome: 'TELESC 800', tactTime: 3 },
        { nome: 'TELESC 600', tactTime: 2 },
        { nome: 'TELESC 400', tactTime: 2 },
        { nome: 'ALT 40', tactTime: 5 },
        { nome: 'ALT 80', tactTime: 4 },
        { nome: 'BAND CHANTELIER', tactTime: 4 },
        { nome: 'CONJUNTO FRENTE FALSA', tactTime: 4 },
        { nome: 'CONJUNTO FRENTE FALSA (5ND)', tactTime: 3 },
        { nome: 'RACK MRM 3U ', tactTime: 6.25 },
        { nome: 'RACK MRM 5U', tactTime: 6.25 },
        { nome: 'CAIXA ORG. PRETA', tactTime: 4.25 },
        { nome: 'CAIXA ORG. BRANCA', tactTime: 4.25 },
    ];

    // Objeto para gerenciar o estado
    let estadoAtual = {
        produtoAtivo: PRODUTOS[0].nome,
        // Cache: agora armazena { ciclo: { obs: string, concluido: boolean } }
        observacoesSalvas: {} 
    };
    
    // Variáveis para controle de pausa
    let isPaused = false;
    let tempoParadoTotal = 0; // Acúmulo de tempo de pausa em segundos
    let horaInicioPausa = 0; // Momento da última pausa em segundos

    // -----------------------------------------------------------------------------------
    // FUNÇÕES DE PERSISTÊNCIA (localStorage)
    // -----------------------------------------------------------------------------------

    /**
     * Carrega todas as observações salvas para o produto atual.
     * @param {string} produto Nome do produto.
     * @returns {Object} Estrutura { ciclo: { obs: string, concluido: boolean } }.
     */
    function carregarObservacoes(produto) {
        try {
            const data = localStorage.getItem(`obs_${produto}`);
            const savedData = data ? JSON.parse(data) : {};
            
            // Garante que a estrutura seja a esperada, tratando dados legados.
            for (const ciclo in savedData) {
                if (typeof savedData[ciclo] !== 'object' || savedData[ciclo] === null) {
                    // Trata dados legados (string simples)
                    savedData[ciclo] = { obs: savedData[ciclo] || '', concluido: true };
                }
                if (savedData[ciclo].concluido === undefined) {
                    // Se 'concluido' estiver faltando, assume true (padrão)
                    savedData[ciclo].concluido = true;
                }
            }
            return savedData;
        } catch (e) {
            console.error("Erro ao carregar observações:", e);
            return {};
        }
    }

    /**
     * Garante que o objeto de estado/observação exista no cache.
     * @param {number} ciclo Número do ciclo.
     */
    function ensureCycleDataExists(ciclo) {
        if (!estadoAtual.observacoesSalvas[ciclo]) {
            // Se não existe, assume padrão: concluído e obs vazia
            estadoAtual.observacoesSalvas[ciclo] = { obs: '', concluido: true };
        }
    }
    
    /**
     * Salva o status de conclusão de um ciclo no localStorage e atualiza a tela.
     * @param {string} produto Nome do produto.
     * @param {number} ciclo Número do ciclo.
     * @param {boolean} isChecked Status de conclusão.
     */
    function salvarStatus(produto, ciclo, isChecked) {
        ensureCycleDataExists(ciclo);
        
        // 1. Atualiza o status no cache
        estadoAtual.observacoesSalvas[ciclo].concluido = isChecked;
        
        // 2. Referências aos elementos
        // Pega o span de status que foi criado (se for um ciclo passado)
        const statusTextSpan = document.getElementById(`status-celula_${produto}_${ciclo}`); 
        const obsInput = document.getElementById(`obs_${produto}_${ciclo}`);

        // 3. Atualiza a aparência do Status na tela imediatamente
        if (statusTextSpan) {
            if (isChecked) {
                statusTextSpan.className = 'status-celula status-concluido';
                statusTextSpan.textContent = 'CONCLUÍDO';
            } else {
                statusTextSpan.className = 'status-celula status-nao-concluido';
                statusTextSpan.textContent = 'NÃO CONCLUÍDO';
            }
        }
        
        // 4. Se a observação for o texto padrão, atualiza-a para refletir o status.
        //    Apenas atualiza o texto se ele for um dos textos Padrão ou vazio
        const currentObs = estadoAtual.observacoesSalvas[ciclo].obs;
        const defaultObsTexts = ['Ciclo concluído', 'NÃO CONCLUÍDO', 'Fim do turno atingido', ''];
        
        if (defaultObsTexts.includes(currentObs.trim())) {
            let newObsText = '';
            if (isChecked) {
                // Tenta manter o status de Fim de Turno se for o caso
                const horaCaixa = document.getElementById(`hora_${produto}_${ciclo}`);
                const isEndOfShift = horaCaixa && horaCaixa.value === TURNO_FIM;
                newObsText = isEndOfShift ? 'Fim do turno atingido' : 'Ciclo concluído';
            } else {
                newObsText = 'NÃO CONCLUÍDO';
            }
            
            // Atualiza o input e o cache com o novo texto
            if (obsInput) {
                obsInput.value = newObsText;
            }
            estadoAtual.observacoesSalvas[ciclo].obs = newObsText;
        }


        // 5. Salva no localStorage
        salvarNoLocalStorage(produto);
        
        // 6. Atualiza o dashboard de contagem
        atualizarContagemDashboard();
    }

    /**
     * Salva uma observação específica no localStorage e no cache.
     * **Chamada pelo evento ONINPUT (alteração imediata do texto).**
     * @param {string} produto Nome do produto.
     * @param {number} ciclo Número do ciclo.
     * @param {string} texto Texto da observação.
     */
    function salvarObservacao(produto, ciclo, texto) {
        ensureCycleDataExists(ciclo);

        // 1. Atualiza o texto
        estadoAtual.observacoesSalvas[ciclo].obs = texto.trim();

        // 2. Salva no localStorage (Salvamento imediato, corrigindo o problema de sobrescrita)
        salvarNoLocalStorage(produto);
    }

    /**
     * Lógica central para salvar o estado atual do produto no localStorage.
     * @param {string} produto Nome do produto.
     */
    function salvarNoLocalStorage(produto) {
        // 1. Limpa entradas vazias: remove o ciclo se a observação estiver vazia E o status for o padrão (concluído)
        for (const ciclo in estadoAtual.observacoesSalvas) {
            const data = estadoAtual.observacoesSalvas[ciclo];
            if (data.obs.trim() === "" && data.concluido === true) {
                delete estadoAtual.observacoesSalvas[ciclo];
            }
        }
        
        try {
            localStorage.setItem(`obs_${produto}`, JSON.stringify(estadoAtual.observacoesSalvas));
        } catch (e) {
            console.error("Erro ao salvar observação/status:", e);
        }
    }
    
    // -----------------------------------------------------------------------------------
    // FUNÇÃO DE RESET
    // -----------------------------------------------------------------------------------

    /**
     * Remove todas as observações do produto ativo do localStorage e recarrega a aba.
     */
    function resetarObservacoes() {
        const produto = estadoAtual.produtoAtivo;
        
        if (confirm(`Tem certeza que deseja apagar TODAS as observações salvas para o produto "${produto}"? Esta ação não pode ser desfeita.`)) {
            try {
                // Remove o item do localStorage
                localStorage.removeItem(`obs_${produto}`);
                
                // Limpa o cache de observações na memória
                estadoAtual.observacoesSalvas = {};
                
                // Recarrega o conteúdo da aba para refletir a mudança
                trocarAba(produto);
                
                // Atualiza o dashboard de contagem
                atualizarContagemDashboard();
                
                alert(`Observações para "${produto}" foram resetadas com sucesso!`);
            } catch (e) {
                console.error("Erro ao resetar observações:", e);
                alert("Erro ao tentar resetar as observações.");
            }
        }
    }
    
    // -----------------------------------------------------------------------------------
    // FUNÇÕES DE UTILIDADE DE TEMPO
    // -----------------------------------------------------------------------------------

    /** Obtém o horário atual em segundos */
    function getNowInSeconds() {
        const now = new Date();
        const h = now.getHours();
        const m = now.getMinutes();
        const s = now.getSeconds();
        return h * 3600 + m * 60 + s;
    }

    /** Converte "HH:MM:SS" para total de segundos. */
    function timeToSeconds(tempo) {
        const partes = tempo.split(':').map(Number);
        const h = partes[0] || 0;
        const m = partes[1] || 0;
        const s = partes[2] || 0;
        return h * 3600 + m * 60 + s;
    }

    /** Converte total de segundos para "HH:MM:SS". */
    function secondsToTime(totalSegundos) {
        const total = Math.round(totalSegundos);
        const segundos = total % 60;
        const minutos = Math.floor(total / 60) % 60;
        const horas = Math.floor(total / 3600);
        
        return [horas, minutos, segundos]
            .map(t => t.toString().padStart(2, '0'))
            .join(':');
    }
    
    /** Converte segundos para formato de contagem regressiva (HH:MM:SS) */
    function secondsToCountdown(totalSegundos) {
        if (totalSegundos < 0) return "00:00:00"; 
        const total = Math.round(totalSegundos);
        const segundos = total % 60;
        const minutos = Math.floor(total / 60) % 60;
        const horas = Math.floor(total / 3600);
        
        return [horas, minutos, segundos]
            .map(t => t.toString().padStart(2, '0'))
            .join(':');
    }


    /**
     * Adiciona minutos a um tempo, considerando o tempo residual após os intervalos.
     */
    function adicionarMinutosComIntervalos(tempoInicial, minutosAdicionar) {
        let tempoSegundos = timeToSeconds(tempoInicial);
        let segundosRestantes = minutosAdicionar * 60;
        
        // Adiciona o tempo de parada acumulado ao início do cálculo
        if (tempoSegundos === timeToSeconds(TURNO_INICIO)) {
            tempoSegundos += tempoParadoTotal;
        }

        // Laço que conta o tempo produtivo segundo a segundo
        while (segundosRestantes > 0) {
            
            // Se o próximo segundo já ultrapassa o fim do turno, encerra aqui.
            if (tempoSegundos + 1 > TURNO_FIM_SEGUNDOS) {
                return TURNO_FIM;
            }

            // Avança um segundo
            tempoSegundos++;
            
            let emIntervalo = false;
            
            // Verifica se o tempo atual caiu em algum intervalo de pausa
            for (const intervalo of INTERVALOS) {
                const inicioSegundos = timeToSeconds(intervalo.inicio);
                const fimSegundos = timeToSeconds(intervalo.fim);

                // Se o tempo está dentro do intervalo de pausa
                if (tempoSegundos > inicioSegundos && tempoSegundos <= fimSegundos) {
                    // Pula o tempo de descanso
                    tempoSegundos = fimSegundos;
                    emIntervalo = true;
                    break;
                }
            }
            
            // Se não estamos em um intervalo, este foi um segundo produtivo
            if (!emIntervalo) {
                segundosRestantes--;
            }
        }
        
        // Retorna o tempo final. Se for maior que o fim do turno, retorna o fim do turno.
        return secondsToTime(Math.min(tempoSegundos, TURNO_FIM_SEGUNDOS));
    }
    
    // -----------------------------------------------------------------------------------
    // FUNÇÕES DE CONTROLE DE LINHA
    // -----------------------------------------------------------------------------------

    function pararLinha() {
        if (isPaused) return;

        horaInicioPausa = getNowInSeconds();
        isPaused = true;
        
        document.getElementById('pararLinha').style.display = 'none';
        document.getElementById('continuarLinha').style.display = 'inline-block';
        document.getElementById('relogio').style.backgroundColor = '#e74c3c';

        lerTextoEmVoz("Linha de produção parada. Aguardando a continuação.");
        // Atualiza o relógio para refletir a pausa no dashboard de contagem
        atualizarRelogio();
    }

    function continuarLinha() {
        if (!isPaused) return;

        const tempoParadoAgora = getNowInSeconds() - horaInicioPausa;
        tempoParadoTotal += tempoParadoAgora;
        isPaused = false;
        horaInicioPausa = 0;
        
        document.getElementById('pararLinha').style.display = 'inline-block';
        document.getElementById('continuarLinha').style.display = 'none';
        document.getElementById('relogio').style.backgroundColor = '#ecf0f1';
        
        // Recarrega o conteúdo da aba para recalcular os horários com o novo tempoParadoTotal
        trocarAba(estadoAtual.produtoAtivo);

        lerTextoEmVoz(`Linha continuada. Tempo de parada acumulado: ${secondsToTime(tempoParadoTotal)}.`);
        // Atualiza o relógio para refletir a continuação e recalcular o próximo evento
        atualizarRelogio(); 
    }

    // -----------------------------------------------------------------------------------
    // FUNÇÕES DE GERAÇÃO E EXPORTAÇÃO
    // -----------------------------------------------------------------------------------

    /**
     * GERA O NOVO LAYOUT VERTICAL DA TABELA.
     */
    function gerarConteudoAba(nomeProduto, tactTime) {
        let tableRows = '';
        let tempoAnterior = TURNO_INICIO;
        const limiteCiclos = 500; 
        const minutosTact = tactTime;
        const horarioAtualBrasilia = secondsToTime(getNowInSeconds()); 
        const defaultObsTexts = ['Ciclo concluído', 'NÃO CONCLUÍDO', 'Fim do turno atingido', ''];
        
        // Carrega as observações salvas no cache
        estadoAtual.observacoesSalvas = carregarObservacoes(nomeProduto);
        const observacoesSalvas = estadoAtual.observacoesSalvas; 


        for (let i = 1; i <= limiteCiclos; i++) {
            
            if (timeToSeconds(tempoAnterior) >= TURNO_FIM_SEGUNDOS) {
                break; 
            }

            let tempoAtual = adicionarMinutosComIntervalos(tempoAnterior, minutosTact);
            let corDestaque = '';
            let statusText = '';
            let statusClasseGeral = '';
            let textoObservacao = ''; 
            
            const cicloData = observacoesSalvas[i] || {};
            const isConcluidoSalvo = cicloData.concluido !== undefined ? cicloData.concluido : true; // Padrão: true
            const observacaoPersonalizada = cicloData.obs !== undefined ? cicloData.obs : ''; 
            
            const isPastCycle = timeToSeconds(tempoAtual) <= timeToSeconds(horarioAtualBrasilia);

            if (isPastCycle) {
                // CICLO PASSADO: RENDERIZA O CHECKBOX e o STATUS dinâmico
                
                const isChecked = isConcluidoSalvo;
                
                // 1. Status Text and Class based on saved status
                if (isChecked) {
                    statusText = 'CONCLUÍDO';
                    statusClasseGeral = 'status-concluido';
                    
                    if (observacaoPersonalizada && !defaultObsTexts.includes(observacaoPersonalizada.trim())) {
                        // Se há um texto salvo e NÃO é um dos padrões, usa o texto salvo (customizado)
                        textoObservacao = observacaoPersonalizada;
                    } else {
                        // Caso contrário, define o texto padrão para "CONCLUÍDO"
                        textoObservacao = (timeToSeconds(tempoAtual) === TURNO_FIM_SEGUNDOS) ? 'Fim do turno atingido' : 'Ciclo concluído';
                    }

                } else {
                    statusText = 'NÃO CONCLUÍDO';
                    statusClasseGeral = 'status-nao-concluido';
                    
                    if (observacaoPersonalizada && !defaultObsTexts.includes(observacaoPersonalizada.trim())) {
                        // Se há um texto salvo e NÃO é um dos padrões, usa o texto salvo (customizado)
                        textoObservacao = observacaoPersonalizada;
                    } else {
                        // Caso contrário, define o texto padrão para "NÃO CONCLUÍDO"
                        textoObservacao = 'NÃO CONCLUÍDO'; 
                    }
                }
                
                // 2. Checkbox HTML
                const checkedAttribute = isChecked ? 'checked' : '';
                const checkboxHtml = `
                    <input type="checkbox" 
                        id="check_${nomeProduto}_${i}" 
                        ${checkedAttribute}
                        onchange="salvarStatus('${nomeProduto}', ${i}, this.checked)"
                        style="cursor: pointer;">
                `;
                
                // Linha da Tabela com Checkbox e Status Text
                tableRows += `
                    <tr>
                        <td>${i}</td>
                        <td>
                            <input type="time" id="hora_${nomeProduto}_${i}" value="${tempoAtual.substring(0, 8)}" step="1" readonly ${corDestaque}>
                        </td>
                        <td id="status_${nomeProduto}_${i}">
                            ${checkboxHtml}
                            <span class="status-celula ${statusClasseGeral}" 
                                id="status-celula_${nomeProduto}_${i}">
                                ${statusText}
                            </span>
                        </td>
                        <td>
                            <input type="text" 
                                id="obs_${nomeProduto}_${i}" 
                                value="${textoObservacao}" 
                                class="observation-input"
                                oninput="salvarObservacao('${nomeProduto}', ${i}, this.value)">
                        </td>
                    </tr>
                `;

            } else {
                // CICLO FUTURO: RENDERIZA APENAS O TEXTO 'ANDAMENTO'
                statusText = 'ANDAMENTO';
                statusClasseGeral = 'status-andamento';
                
                // Se houver observação salva (manual) e NÃO for um texto padrão, exibe-a, senão deixa vazio.
                if (observacaoPersonalizada && !defaultObsTexts.includes(observacaoPersonalizada.trim())) {
                    textoObservacao = observacaoPersonalizada; 
                } else {
                    textoObservacao = ''; 
                }

                tableRows += `
                    <tr>
                        <td>${i}</td>
                        <td>
                            <input type="time" id="hora_${nomeProduto}_${i}" value="${tempoAtual.substring(0, 8)}" step="1" readonly ${corDestaque}>
                        </td>
                        <td class="${statusClasseGeral}" id="status_${nomeProduto}_${i}">
                            ${statusText}
                        </td>
                        <td>
                            <input type="text" 
                                id="obs_${nomeProduto}_${i}" 
                                value="${textoObservacao}" 
                                class="observation-input"
                                oninput="salvarObservacao('${nomeProduto}', ${i}, this.value)">
                        </td>
                    </tr>
                `;
            }
            
            tempoAnterior = tempoAtual;
            
            if (timeToSeconds(tempoAtual) === TURNO_FIM_SEGUNDOS) {
                break;
            }
        }

        let html = `
            <div class="tact-time-info">
                Produto Ativo: <strong>${nomeProduto}</strong> (Takt Time: ${tactTime} minutos)
                ${tempoParadoTotal > 0 ? `<span style="color: red; margin-left: 20px;">(Tempo de Parada Acumulado: ${secondsToTime(tempoParadoTotal)})</span>` : ''}
            </div>
            
            <div style="margin-bottom: 10px;">
                <h2>Horários de Ciclo Calculados (Relatório Diário)</h2>
            </div>

            <div class="log-container">
                <table class="production-log">
                    <thead>
                        <tr>
                            <th>Ciclo #</th>
                            <th>Horário Final</th>
                            <th>Status</th> 
                            <th>Observações</th>
                        </tr>
                    </thead>
                    <tbody id="tabela-corpo-${nomeProduto}">
                        ${tableRows}
                    </tbody>
                </table>
            </div>
        `;
        return html;
    }


    /**
     * Alterna a aba ativa e carrega o conteúdo.
     * Agora carrega com base no valor do SELECT.
     */
    function trocarAba(novoProduto) {
        estadoAtual.produtoAtivo = novoProduto;
        
        // Atualiza o select para garantir que ele reflita o estado (caso a função seja chamada de outro lugar)
        const selectElement = document.getElementById('product-select');
        if(selectElement) {
            selectElement.value = novoProduto;
        }

        // Limpa o cache e recarrega as observações para o novo produto
        estadoAtual.observacoesSalvas = carregarObservacoes(novoProduto);

        const produtoData = PRODUTOS.find(p => p.nome === novoProduto);
        if (produtoData) {
            // Re-renderiza o conteúdo da aba, o que carrega os valores salvos
            document.getElementById('product-content').innerHTML = gerarConteudoAba(produtoData.nome, produtoData.tactTime);
            
            // Atualiza a contagem dos dashboards sempre que a aba é trocada
            atualizarContagemDashboard();
        }
    }


    /**
     * Exporta os dados do relatório para um arquivo CSV (Excel).
     */
    function exportarParaExcel() {
        const produto = estadoAtual.produtoAtivo;
        const linhas = [];
        
        // Cabeçalho do CSV
        linhas.push(["Ciclo #", "Horário Final", "Status", "Observações", "Produto", "Takt Time (min)", "Tempo Parado Total Acumulado (s)"]);

        // Coleta de dados
        const produtoData = PRODUTOS.find(p => p.nome === produto);
        const tactTime = produtoData ? produtoData.tactTime.toString().replace('.', ',') : "N/A";
        
        const limiteCiclos = 500;
        for (let i = 1; i <= limiteCiclos; i++) {
            const horaInput = document.getElementById(`hora_${produto}_${i}`);
            
            let status = "N/A";
            const statusCell = document.getElementById(`status-celula_${produto}_${i}`) || document.getElementById(`status_${produto}_${i}`);

            if (statusCell) {
                // Tenta pegar o texto dentro do <span> (ciclos passados) ou o texto direto (ciclos futuros)
                status = statusCell.textContent.trim(); 
            }
            
            const obsInput = document.getElementById(`obs_${produto}_${i}`);

            if (horaInput) {
                const hora = horaInput.value;
                const obs = obsInput ? obsInput.value.replace(/"/g, '""') : ""; 
                
                // Usa ponto e vírgula (;) como separador para compatibilidade com Excel em PT-BR/Europa
                linhas.push([i, hora, status, `"${obs}"`, produto, tactTime, tempoParadoTotal]);
            } else {
                break; 
            }
        }

        // Formata para CSV
        let csvContent = linhas.map(e => e.join(";")).join("\n"); 

        // Lógica de download
        const blob = new Blob([csvContent], { type: 'text/csv;charset=utf-8;' });
        const link = document.createElement("a");
        const url = URL.createObjectURL(blob);
        
        link.setAttribute("href", url);
        link.setAttribute("download", `Relatorio_Diario_${produto.replace(/ /g, '_')}_${new Date().toLocaleDateString('pt-BR').replace(/\//g, '-')}.csv`);
        link.style.visibility = 'hidden';
        document.body.appendChild(link);
        link.click();
        document.body.removeChild(link);
        
        alert("Relatório exportado com sucesso!");
    }


    // -----------------------------------------------------------------------------------
    // FUNÇÕES DE ATUALIZAÇÃO DO RELÓGIO E DASHBOARD
    // -----------------------------------------------------------------------------------

    /**
     * Calcula quantos ciclos CONCLUÍDOS e NÃO CONCLUÍDOS existem
     * entre os ciclos que já deveriam ter finalizado (passados).
     */
    function calcularCiclosConcluidosEfalhos(horarioBrasilia, produto) {
        const nowInSeconds = timeToSeconds(horarioBrasilia);
        let concluidos = 0;
        let naoConcluidos = 0;
        const limiteCiclos = 500;
        
        if (!produto) return { concluidos: 0, naoConcluidos: 0 };

        // Carrega o estado atual (incluindo o status de conclusão)
        const observacoesSalvas = carregarObservacoes(produto); 

        for (let i = 1; i <= limiteCiclos; i++) {
            const horaCaixa = document.getElementById(`hora_${produto}_${i}`);
            
            if (horaCaixa) {
                const cicloSegundos = timeToSeconds(horaCaixa.value);
                
                // Só contamos os ciclos que já se passaram
                if (cicloSegundos <= nowInSeconds) {
                    
                    const cicloData = observacoesSalvas[i] || {};
                    // Padrão é TRUE para ciclos que já passaram e não foram modificados
                    const isConcluidoSalvo = cicloData.concluido !== undefined ? cicloData.concluido : true; 

                    if (isConcluidoSalvo) {
                        concluidos++;
                    } else {
                        naoConcluidos++;
                    }
                } else {
                    break; // Se o ciclo está no futuro, pare a contagem
                }
            } else {
                break;
            }
        }
        return { concluidos, naoConcluidos };
    }


    /**
     * Atualiza os dashboards de contagem (Normal e Fullscreen).
     */
    function atualizarContagemDashboard() {
        const nowInSeconds = getNowInSeconds();
        const horarioBrasilia = secondsToTime(nowInSeconds);
        const contagem = calcularCiclosConcluidosEfalhos(horarioBrasilia, estadoAtual.produtoAtivo);
        
        // Normal
        const concluidosElement = document.getElementById('ciclosCompletos');
        const naoConcluidosElement = document.getElementById('ciclosNaoCompletos');
        
        if (concluidosElement) {
             concluidosElement.querySelector('.display-value').textContent = contagem.concluidos;
        }
        if (naoConcluidosElement) {
             naoConcluidosElement.querySelector('.display-value').textContent = contagem.naoConcluidos;
        }
        
        // Fullscreen
        const fsConcluidosElement = document.getElementById('fs-ciclosCompletos');
        const fsNaoConcluidosElement = document.getElementById('fs-ciclosNaoCompletos');
        const fsProductInfo = document.getElementById('fs-product-info');

        const produtoData = PRODUTOS.find(p => p.nome === estadoAtual.produtoAtivo);

        if (fsConcluidosElement) {
            fsConcluidosElement.querySelector('.fs-display-value').textContent = contagem.concluidos;
        }
        if (fsNaoConcluidosElement) {
            fsNaoConcluidosElement.querySelector('.fs-display-value').textContent = contagem.naoConcluidos;
        }
        if (fsProductInfo && produtoData) {
             fsProductInfo.textContent = `Produto Ativo: ${produtoData.nome} (Takt Time: ${produtoData.tactTime} min)`;
        }
    }


    /**
     * Atualiza o Status e o campo de Observação de cada ciclo na tabela, preservando edições.
     * **PRINCIPAL FUNÇÃO MODIFICADA PARA ATUALIZAÇÃO AUTOMÁTICA DE STATUS.**
     */
    function atualizarStatusTabela(horarioBrasilia) {
        const produto = estadoAtual.produtoAtivo;
        const nowInSeconds = timeToSeconds(horarioBrasilia);
        const limiteCiclos = 500;
        const defaultObsTexts = ['Ciclo concluído', 'NÃO CONCLUÍDO', 'Fim do turno atingido', ''];
        
        // Carrega as observações do cache para a verificação
        const observacoesSalvas = estadoAtual.observacoesSalvas;

        for (let i = 1; i <= limiteCiclos; i++) {
            const horaCaixa = document.getElementById(`hora_${produto}_${i}`);
            const obsInput = document.getElementById(`obs_${produto}_${i}`); 
            const statusCell = document.getElementById(`status_${produto}_${i}`); // The TD container for status
            
            if (horaCaixa && obsInput && statusCell) {
                const cicloSegundos = timeToSeconds(horaCaixa.value);
                const isEndOfShift = horaCaixa.value === TURNO_FIM;
                
                // Garante que o objeto de dados exista, assumindo concluído: true por padrão
                ensureCycleDataExists(i);
                const cicloData = observacoesSalvas[i]; 
                const observacaoSalva = cicloData.obs;
                const isConcluidoSalvo = cicloData.concluido;

                // Verificamos se a observação salva no cache é uma observação CUSTOMIZADA
                const isCustomObservation = observacaoSalva && !defaultObsTexts.includes(observacaoSalva.trim());


                if (cicloSegundos <= nowInSeconds) {
                    // CICLO CONCLUÍDO (PASSADO)
                    
                    // --- LÓGICA DE ATUALIZAÇÃO AUTOMÁTICA DE STATUS ---
                    // 1. Checa se o statusCell ainda está no formato "ANDAMENTO" (apenas texto)
                    const currentStatusText = statusCell.textContent.trim();
                    if (currentStatusText === 'ANDAMENTO') {
                        
                        // O ciclo acaba de passar. Atualiza o HTML para incluir o checkbox.
                        const statusText = isConcluidoSalvo ? 'CONCLUÍDO' : 'NÃO CONCLUÍDO';
                        const statusClasseGeral = isConcluidoSalvo ? 'status-concluido' : 'status-nao-concluido';
                        const checkedAttribute = isConcluidoSalvo ? 'checked' : '';
                        
                        // Cria o HTML do Checkbox e do Span de Status
                        const newContent = `
                            <input type="checkbox" 
                                id="check_${produto}_${i}" 
                                ${checkedAttribute}
                                onchange="salvarStatus('${produto}', ${i}, this.checked)"
                                style="cursor: pointer;">
                            <span class="status-celula ${statusClasseGeral}" 
                                id="status-celula_${produto}_${i}">
                                ${statusText}
                            </span>
                        `;
                        
                        // 2. Atualiza o conteúdo da célula TD
                        statusCell.innerHTML = newContent;
                        
                        // 3. Força a chamada de salvarStatus para atualizar o localStorage e o Dashboard
                        // Isso é crucial para que o novo ciclo (agora passado) seja contado no dashboard
                        // e tenha seu status (default: CONCLUÍDO) salvo, mesmo que não haja observação.
                        // O 'salvarStatus' também garante que o texto de observação padrão seja definido.
                        salvarStatus(produto, i, isConcluidoSalvo); 
                    }
                    // --- FIM LÓGICA DE ATUALIZAÇÃO AUTOMÁTICA DE STATUS ---

                    // 4. Lógica de atualização de Observação (Preserva Customizada)
                    if (!isCustomObservation) {
                        if (isConcluidoSalvo) {
                             if (isEndOfShift) {
                                obsInput.value = 'Fim do turno atingido';
                             } else {
                                obsInput.value = 'Ciclo concluído';
                             }
                        } else {
                             obsInput.value = 'NÃO CONCLUÍDO';
                        }
                        
                        // Também atualiza o cache para manter a consistência, se não for customizado.
                        cicloData.obs = obsInput.value;
                    }

                } else {
                    // CICLO EM ANDAMENTO (FUTURO)
                    // Se a observação NÃO é customizada, deixa vazio.
                    if (!isCustomObservation) {
                        obsInput.value = '';
                        cicloData.obs = '';
                    }
                }
            } else {
                break;
            }
        }
        
        // Salvamento final para garantir a persistência das observações padrão atualizadas 
        // (ex: "Fim do turno atingido") que não passaram pela função salvarStatus.
        salvarNoLocalStorage(produto);
    }


    /**
     * Atualiza o relógio, o dashboard de ciclos e a contagem regressiva, e verifica os avisos de voz.
     */
    function atualizarRelogio() {
        const now = new Date();
        const horarioBrasilia = [
            now.getHours().toString().padStart(2, '0'),
            now.getMinutes().toString().padStart(2, '0'),
            now.getSeconds().toString().padStart(2, '0')
        ].join(':');
        
        // Atualiza os relógios (Normal e Fullscreen)
        document.getElementById('relogio').textContent = horarioBrasilia;
        const fsRelogioElement = document.getElementById('fs-relogio');
        if (fsRelogioElement) {
             fsRelogioElement.textContent = horarioBrasilia;
        }
        
        // 1. Atualiza o Status e Observações da Tabela (agora com atualização automática do status)
        atualizarStatusTabela(horarioBrasilia);

        // 2. Atualiza os Dashboards de Ciclos Concluídos e Não Concluídos
        atualizarContagemDashboard();

        // 3. Verifica e atualiza a contagem regressiva
        atualizarContagemRegressiva(horarioBrasilia);
        
        // 4. Avisos de Voz
        if (timeToSeconds(horarioBrasilia) <= TURNO_FIM_SEGUNDOS && !isPaused) {
            verificarHorarioCaixas(horarioBrasilia, estadoAtual.produtoAtivo);
        }
    }
    
    /**
     * Calcula e exibe o tempo restante para o próximo evento (ciclo, início/fim de pausa, fim de turno).
     */
    function atualizarContagemRegressiva(horarioBrasilia) {
        const countdownElement = document.getElementById('countdown');
        const fsCountdownElement = document.getElementById('fs-countdown');
        const nowInSeconds = timeToSeconds(horarioBrasilia);
        const produtoAtivo = estadoAtual.produtoAtivo;
        
        let countdownHTML = '';
        let fsCountdownHTML = '';
        
        // 1. Lógica para quando a linha está parada (PRIORIDADE MÁXIMA)
        if (isPaused) {
            const tempoParadoAgora = getNowInSeconds() - horaInicioPausa;
            const tempoFormatado = secondsToCountdown(tempoParadoAgora);

            countdownHTML = `
                <strong style="color: #e74c3c;">LINHA PARADA</strong>
                <span class="display-value" style="color: #e74c3c;">${tempoFormatado}</span>
            `;
            fsCountdownHTML = `
                <strong style="font-size: 1.2em;">LINHA PARADA</strong>
                <span class="fs-display-value">${tempoFormatado}</span>
            `;
            
            countdownElement.innerHTML = countdownHTML;
            countdownElement.style.backgroundColor = '#f9ebea'; // Cor de alerta

            if (fsCountdownElement) {
                 fsCountdownElement.innerHTML = fsCountdownHTML;
                 fsCountdownElement.style.backgroundColor = '#e74c3c';
            }

            return;
        }

        // --- 2. Lógica para quando a linha está rodando: Encontrar o evento mais próximo ---
        
        let proximoEvento = null;
        let minTempoSegundos = TURNO_FIM_SEGUNDOS + 1;

        // 2a. Verificar Horários de Ciclo Calculados (Contagem Regressiva do Takt Time)
        const limiteCiclos = 500;
        for (let i = 1; i <= limiteCiclos; i++) {
            const horaCaixa = document.getElementById(`hora_${produtoAtivo}_${i}`);
            
            if (horaCaixa) {
                const cicloSegundos = timeToSeconds(horaCaixa.value);
                
                // Se o ciclo ainda não passou e é o mais próximo até agora
                if (cicloSegundos > nowInSeconds && cicloSegundos < minTempoSegundos) {
                    minTempoSegundos = cicloSegundos;
                    proximoEvento = { aviso: 'Próximo Ciclo', tempoSegundos: cicloSegundos };
                }
            } else {
                break;
            }
        }
        
        // 2b. Verificar Início/Fim dos Intervalos Fixos
        for (const intervalo of INTERVALOS) {
            const inicioSegundos = timeToSeconds(intervalo.inicio);
            const fimSegundos = timeToSeconds(intervalo.fim);
            
            // Próximo Evento: Início do Intervalo (Se for o mais próximo)
            if (inicioSegundos > nowInSeconds && inicioSegundos < minTempoSegundos) {
                minTempoSegundos = inicioSegundos;
                proximoEvento = { aviso: 'Início do ' + intervalo.nome, tempoSegundos: inicioSegundos };
            }
            
            // Próximo Evento: Fim do Intervalo / Retorno (se já estivermos dentro)
            if (nowInSeconds < fimSegundos && nowInSeconds >= inicioSegundos) {
                minTempoSegundos = fimSegundos;
                proximoEvento = { aviso: 'Retorno do ' + intervalo.nome, tempoSegundos: fimSegundos };
            }
        }
        
        // 2c. Verificar Fim do Turno (Fallback)
        if (TURNO_FIM_SEGUNDOS > nowInSeconds && TURNO_FIM_SEGUNDOS < minTempoSegundos) {
            minTempoSegundos = TURNO_FIM_SEGUNDOS;
            proximoEvento = { aviso: 'FIM DO TURNO', tempoSegundos: TURNO_FIM_SEGUNDOS };
        }


        // 3. Exibir o Evento Mais Próximo
        if (proximoEvento) {
            const segundosRestantes = proximoEvento.tempoSegundos - nowInSeconds;
            const countdownTempo = secondsToCountdown(segundosRestantes);
            
            countdownHTML = `
                <strong>${proximoEvento.aviso}:</strong>
                <span class="display-value" style="color: #3498db;">${countdownTempo}</span>
            `;
            fsCountdownHTML = `
                <strong style="font-size: 1.2em;">${proximoEvento.aviso}:</strong>
                <span class="fs-display-value">${countdownTempo}</span>
            `;
            
            countdownElement.innerHTML = countdownHTML;
            countdownElement.style.backgroundColor = '#f0f8ff';
            
            if (fsCountdownElement) {
                 fsCountdownElement.innerHTML = fsCountdownHTML;
                 fsCountdownElement.style.backgroundColor = '#3498db';
            }
            
        } else {
            countdownHTML = `
                <strong>FIM DO TURNO</strong>
                <span class="display-value" style="color: #2c3e50;">17:30:00 Alcançado</span>
            `;
             fsCountdownHTML = `
                <strong style="font-size: 1.2em;">FIM DO TURNO</strong>
                <span class="fs-display-value">17:30:00 Alcançado</span>
            `;
            
            countdownElement.innerHTML = countdownHTML;
            countdownElement.style.backgroundColor = '#ecf0f1';
            
            if (fsCountdownElement) {
                 fsCountdownElement.innerHTML = fsCountdownHTML;
                 fsCountdownElement.style.backgroundColor = '#2c3e50';
            }
        }
    }


    /**
     * Verifica se o horário do relógio coincide com algum horário de intervalo ou ciclo.
     */
    function verificarHorarioCaixas(horarioBrasilia, produto) {
        
        // 1. Avisos de Intervalo (Início)
        for (let i = 0; i < INTERVALOS.length; i++) {
            const inicioIntervalo = INTERVALOS[i].inicio;

            if (inicioIntervalo === horarioBrasilia) {
                lerTextoEmVoz(INTERVALOS[i].avisoVoz); 
                return; 
            }
        }

        // 2. Avisos de Ciclo INICIADO (Início do turno e Retorno das pausas)
        const horariosCicloIniciadoFixos = [
            TURNO_INICIO,   
            '08:35:00',     
            '12:30:00',     
            '14:05:00'      
        ];
        
        if (horariosCicloIniciadoFixos.includes(horarioBrasilia)) {
            lerTextoEmVoz("Ciclo iniciado");
            return;
        }


        // 3. Avisos de FIM DE CICLO CALCULADOS
        const produtoData = PRODUTOS.find(p => p.nome === produto);
        if (produtoData) {
            const limiteCiclos = 500;
            
            for (let i = 1; i <= limiteCiclos; i++) {
                const horaCaixa = document.getElementById(`hora_${produto}_${i}`);
                
                if (horaCaixa && horaCaixa.value === horarioBrasilia) {
                    
                    lerTextoEmVoz("Ciclo finalizado"); 
                    
                    if (horarioBrasilia === TURNO_FIM) {
                         lerTextoEmVoz("Turno finalizado às 17 horas e 30 minutos.");
                    }
                    return; 
                }
            }
        }
    }

    /**
     * Função para ler o texto em voz alta.
     */
    function lerTextoEmVoz(texto) {
        if (texto.trim() !== "") {
            if (window.speechSynthesis.speaking) {
                window.speechSynthesis.cancel();
            }
            const utterance = new SpeechSynthesisUtterance(texto);
            utterance.lang = 'pt-BR';
            window.speechSynthesis.speak(utterance);
        }
    }
    
    // -----------------------------------------------------------------------------------
    // FUNÇÕES DE TELA CHEIA (FULLSCREEN)
    // -----------------------------------------------------------------------------------
    
    /**
     * Alterna a visibilidade do dashboard em tela cheia.
     */
    function toggleFullscreenDashboard() {
        const fsDashboard = document.getElementById('fullscreenDashboard');
        
        if (fsDashboard.classList.contains('active')) {
            // SAIR
            fsDashboard.classList.remove('active');
            document.body.style.overflow = 'auto'; // Habilita a rolagem normal
            
            // Tenta sair do modo Fullscreen nativo do navegador (se estiver)
            if (document.exitFullscreen) {
                document.exitFullscreen();
            } else if (document.mozCancelFullScreen) { /* Firefox */
                document.mozCancelFullScreen();
            } else if (document.webkitExitFullscreen) { /* Chrome, Safari and Opera */
                document.webkitExitFullscreen();
            } else if (document.msExitFullscreen) { /* IE/Edge */
                document.msExitFullscreen();
            }

        } else {
            // ENTRAR
            fsDashboard.classList.add('active');
            document.body.style.overflow = 'hidden'; // Remove a rolagem
            
            // Tenta entrar no modo Fullscreen nativo do navegador
            const element = fsDashboard;
            if (element.requestFullscreen) {
                element.requestFullscreen();
            } else if (element.mozRequestFullScreen) { /* Firefox */
                element.mozRequestFullScreen();
            } else if (element.webkitRequestFullscreen) { /* Chrome, Safari and Opera */
                element.webkitRequestFullscreen();
            } else if (element.msRequestFullscreen) { /* IE/Edge */
                element.msRequestFullscreen();
            }
        }
    }

    // -----------------------------------------------------------------------------------
    // BLOQUEIO DE TELA (SCREEN WAKE LOCK API)
    // -----------------------------------------------------------------------------------
    
    let wakeLock = null;
    let isRequestingLock = false;

    async function requestWakeLock() {
        if (isRequestingLock || wakeLock !== null || !('wakeLock' in navigator)) {
            return;
        }
        
        isRequestingLock = true;
        
        try {
            wakeLock = await navigator.wakeLock.request('screen');
            console.log('Bloqueio de tela ativado.');
            
            wakeLock.addEventListener('release', () => {
                console.log('Bloqueio de tela liberado.');
                wakeLock = null;
                isRequestingLock = false;
            });
            
        } catch (err) {
            console.error(`Erro ao ativar o Bloqueio de Tela: ${err.name} - ${err.message}`);
            wakeLock = null;
            
        } finally {
            isRequestingLock = false;
        }
    }
    
    document.addEventListener('visibilitychange', () => {
        if (document.visibilityState === 'visible' && wakeLock === null) {
            if(sistemaIniciado) {
                requestWakeLock();
            }
        }
    });

    // -----------------------------------------------------------------------------------
    // INICIALIZAÇÃO DO SISTEMA
    // -----------------------------------------------------------------------------------
    
    let sistemaIniciado = false;
    
    function iniciarSistema() {
        if (sistemaIniciado) return;
        
        requestWakeLock();
        
        const botaoIniciar = document.getElementById('iniciarSistema');
        const botaoParar = document.getElementById('pararLinha');
        const botaoContinuar = document.getElementById('continuarLinha');
        const botaoExportar = document.getElementById('exportarRelatorio');
        const botaoReset = document.getElementById('resetarObservacoes');
        const botaoFullscreen = document.getElementById('fullscreenToggle');


        if (botaoIniciar) {
            botaoIniciar.remove(); 
        }
        if (botaoParar) {
            botaoParar.style.display = 'inline-block'; 
        }
        if (botaoContinuar) {
            botaoContinuar.style.display = 'none'; // Começa desativado
        }
        if (botaoExportar) {
            botaoExportar.style.display = 'inline-block'; // Mostra o botão de exportar
        }
        if (botaoReset) {
            botaoReset.style.display = 'inline-block';
        }
        if (botaoFullscreen) {
            botaoFullscreen.style.display = 'inline-block'; // Mostra o botão de fullscreen
        }
        
        // Inicia a atualização do relógio e status a cada segundo
        setInterval(atualizarRelogio, 1000);
        atualizarRelogio();

        sistemaIniciado = true;
        lerTextoEmVoz("Sistema de avisos iniciado e ativado. Bom trabalho!");
    }

    function inicializar() {
        const selectElement = document.getElementById('product-select');
        
        // 1. Preenche o SELECT de produtos
        PRODUTOS.forEach(produto => {
            const option = document.createElement('option');
            option.value = produto.nome;
            option.textContent = produto.nome;
            selectElement.appendChild(option);
        });

        // 2. Troca para a primeira aba (ou a que estava ativa na sessão)
        trocarAba(estadoAtual.produtoAtivo);

        // 3. Configura Event Listeners
        const botaoIniciar = document.getElementById('iniciarSistema');
        if (botaoIniciar) {
            botaoIniciar.addEventListener('click', iniciarSistema);
        }
        
        document.getElementById('pararLinha').addEventListener('click', pararLinha);
        document.getElementById('continuarLinha').addEventListener('click', continuarLinha);
        
        const botaoReset = document.getElementById('resetarObservacoes');
        if (botaoReset) {
            botaoReset.addEventListener('click', resetarObservacoes);
        }

        // 4. Atualiza a primeira vez para carregar o relógio
        atualizarRelogio();
    }

    // Garante que as funções globais possam ser chamadas pelos botões
    window.exportarParaExcel = exportarParaExcel;
    window.salvarObservacao = salvarObservacao;
    window.resetarObservacoes = resetarObservacoes;
    window.salvarStatus = salvarStatus; 
    window.atualizarContagemDashboard = atualizarContagemDashboard; 
    window.toggleFullscreenDashboard = toggleFullscreenDashboard; // Nova função global
    window.trocarAba = trocarAba; // Garante que o onchange do select funcione

    inicializar();
</script>
</body>
</html>
