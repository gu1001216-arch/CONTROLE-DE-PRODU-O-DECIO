<!DOCTYPE html>
<html lang="pt-br">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Controle de Produ√ß√£o - Turno 1 (Ciclos at√© 17:30)</title>
    
    <meta name="mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="theme-color" content="#2c3e50"> 
    <link rel="manifest" href="manifest.json">
    <style>
        body {
            font-family: Arial, sans-serif;
            background-color: #f4f4f4;
            color: #333;
            margin: 0;
            padding: 0;
        }
        header {
            background-color: #2c3e50;
            color: white;
            padding: 10px 0;
            text-align: center;
        }
        .content {
            padding: 20px;
            text-align: center;
        }
        .relogio-box {
            display: inline-block;
            background-color: #ecf0f1;
            padding: 20px;
            border-radius: 8px;
            font-size: 30px;
            font-weight: bold;
            box-shadow: 0px 4px 8px rgba(0, 0, 0, 0.2);
            margin-bottom: 20px;
        }
        /* Estilos para as abas */
        .tabs {
            overflow-x: auto;
            white-space: nowrap;
            padding-bottom: 10px;
            border-bottom: 2px solid #ccc;
            margin-bottom: 20px;
            text-align: left;
        }
        .tab-button {
            background-color: #ddd;
            border: none;
            padding: 10px 15px;
            cursor: pointer;
            outline: none;
            transition: background-color 0.3s;
            margin-right: 5px;
            border-radius: 5px 5px 0 0;
        }
        .tab-button.active {
            background-color: #2c3e50;
            color: white;
            border-bottom: 2px solid #2c3e50;
        }
        /* Estilos para as caixas de tempo e texto */
        .intervalos, .caixas-extra {
            margin-top: 30px;
            text-align: center;
        }
        .intervalo-box, .caixa-azul, .caixa-rosa {
            display: inline-block;
            padding: 10px 20px;
            border-radius: 8px;
            margin: 10px;
        }
        .intervalo-box {
            background-color: #a2d9f7; /* Azul claro */
        }
        .caixa-azul {
            background-color: #a2d9f7; /* Azul claro */
        }
        .caixa-rosa {
            background-color: #f7b7b7; /* Rosa claro */
        }
        input[type="time"], input[type="text"] {
            font-size: 18px;
            padding: 5px;
            width: 120px;
            text-align: center;
            border: 2px solid #f7b7b7; /* Borda rosa */
            border-radius: 5px;
            background-color: #fff;
        }
        input[type="time"]:focus, input[type="text"]:focus {
            outline: none;
            border-color: #f06292; /* Cor mais forte de rosa no foco */
        }
        .caixas-rosa-multipla {
            display: flex;
            flex-wrap: wrap;
            justify-content: center;
            gap: 10px;
            margin-top: 20px;
        }
        .caixas-rosa-multipla div {
            width: 120px;
        }
        .tact-time-info {
            font-size: 1.2em;
            font-weight: bold;
            color: #2c3e50;
            margin-bottom: 15px;
        }
        /* Estilo para o novo bot√£o de in√≠cio */
        #iniciarSistema {
            padding: 15px 30px; 
            font-size: 20px; 
            font-weight: bold;
            background-color: #2ecc71; /* Verde */
            color: white;
            border: none;
            border-radius: 5px;
            cursor: pointer;
            transition: background-color 0.3s;
            margin-bottom: 20px;
        }
        #iniciarSistema:hover {
            background-color: #27ae60;
        }
    </style>
</head>
<body>

<header>
    <h1>Controle de Produ√ß√£o - 1¬∞ Turno (Tempo Residual Ativo)</h1>
</header>

<div class="content">
    
    <div class="relogio-box" id="relogio">
        Carregando hor√°rio...
    </div>

    <button id="iniciarSistema">
        CLIQUE AQUI PARA INICIAR O SISTEMA DE AVISOS DE VOZ (E MANTER A TELA LIGADA)
    </button>
    <div class="tabs" id="tabs-container">
    </div>

    <div id="product-content">
    </div>

</div>

<script>
    // =======================================================
    // üöÄ IN√çCIO DO WAKE LOCK API (Bloqueio de Tela) üöÄ
    // L√ìGICA REFOR√áADA PARA REATIVAR O LOCK SE FOR LIBERADO
    // =======================================================
    let wakeLock = null;

    /**
     * Tenta solicitar o bloqueio da tela.
     */
    const requestWakeLock = async () => {
        // Se a API n√£o for suportada, sai.
        if (!('wakeLock' in navigator)) {
            console.warn('‚ùå Wake Lock API n√£o suportada neste navegador.');
            return;
        }

        // Se j√° estiver ativo, n√£o tenta novamente.
        if (wakeLock !== null) return;
        
        try {
            // Solicita o bloqueio de tela
            wakeLock = await navigator.wakeLock.request('screen');
            console.log('‚úÖ Screen Wake Lock Ativo! Tela n√£o apagar√°.');

            // Adiciona um listener para REATIVAR o bloqueio se for liberado automaticamente
            wakeLock.addEventListener('release', () => {
                console.log('‚ö†Ô∏è Bloqueio de tela liberado. Tentando reativar...');
                // Tenta reativar o lock imediatamente se a p√°gina estiver vis√≠vel.
                if (document.visibilityState === 'visible') {
                    requestWakeLock();
                } else {
                     wakeLock = null; // Zera a refer√™ncia se foi liberado enquanto estava invis√≠vel.
                }
            });
            
        } catch (err) {
            console.error(`‚ùå Erro ao solicitar Wake Lock: ${err.name}, ${err.message}`);
            wakeLock = null; 
        }
    };

    /**
     * Lida com a visibilidade da p√°gina para tentar reativar o bloqueio ao voltar
     */
    const handleVisibilityChange = () => {
        // Tenta reativar o Wake Lock quando a p√°gina volta a ser vis√≠vel
        if (document.visibilityState === 'visible') {
            console.log('P√°gina ficou vis√≠vel. Tentando reativar Wake Lock.');
            requestWakeLock();
        } else {
             console.log('P√°gina ficou invis√≠vel.');
        }
    };

    // Adiciona o listener de visibilidade para reativar o lock quando o usu√°rio volta para a aba
    document.addEventListener('visibilitychange', handleVisibilityChange);
    
    // =======================================================
    // üõë FIM DO WAKE LOCK API üõë
    // =======================================================


    // -----------------------------------------------------------------------------------
    // DADOS FIXOS E ESTADO GLOBAL (SEM LOCALSTORAGE)
    // -----------------------------------------------------------------------------------

    const TURNO_INICIO = '06:00:00';
    const TURNO_FIM = '17:30:00'; // Finaliza√ß√£o do turno
    const TURNO_FIM_SEGUNDOS = 63000; // 17:30:00 em segundos

    // ATUALIZADO: Avisos de voz para o in√≠cio dos intervalos
    const INTERVALOS = [
        { inicio: '08:20:00', fim: '08:35:00', nome: 'Caf√© 1', avisoVoz: 'Intervalo iniciado, bom caf√© a todos!' },
        { inicio: '11:30:00', fim: '12:30:00', nome: 'Almo√ßo', avisoVoz: 'Intervalo iniciado, bom almo√ßo a todos!' },
        { inicio: '13:50:00', fim: '14:05:00', nome: 'Caf√© 2', avisoVoz: 'Intervalo iniciado, bom caf√© a todos!' },
    ];

    const PRODUTOS = [
        // Lista completa de produtos e seus Tact Times em minutos
        { nome: 'PATCH PANEL PPD24', tactTime: 3 },
        { nome: 'PATCH PANEL PPDB24', tactTime: 4 },
        { nome: 'RACK MRD 3U 470MM', tactTime: 11 },
        { nome: 'RACK MRD 5U 470MM', tactTime: 11 },
        { nome: 'RACK MRD 8U 470MM', tactTime: 11 },
        { nome: 'RACK MRD 12U 470MM', tactTime: 11.5 },
        { nome: 'RACK MRD 3U BS', tactTime: 2 },
        { nome: 'RACK MRD 5U BS', tactTime: 3 },
        { nome: 'RACK MRD 8U BS', tactTime: 5 },
        { nome: 'RACK MRD 12U BS', tactTime: 3 },
        { nome: 'RACK 5U BS OUTDOOR', tactTime: 4 },
        { nome: 'RACK 8U BS OUTDOOR', tactTime: 5 },
        { nome: 'RACK 12U BS OUTDOOR', tactTime: 5 },
        { nome: 'RACK 24U TORRE', tactTime: 2 },
        { nome: 'RACK 36U TORRE', tactTime: 4 },
        { nome: 'RACK 44U TORRE', tactTime: 2 },
        { nome: 'RACK RPD PA 1657', tactTime: 5 },
        { nome: 'RACK RPD PA 2057', tactTime: 4 },
        { nome: 'RACK RPD PA 2457', tactTime: 2 },
        { nome: 'RACK RPD PA 2857', tactTime: 5 },
        { nome: 'RACK RPD PA 3257', tactTime: 5 },
        { nome: 'RACK RPD PA 3657', tactTime: 2 },
        { nome: 'RACK RPD PA 4057', tactTime: 4 },
        { nome: 'RACK RPD PA 4457', tactTime: 2 },
        { nome: 'RACK RPD PP 4457', tactTime: 5 },
        { nome: 'RACK RPD PA 1667', tactTime: 4 },
        { nome: 'RACK RPD PA 2067', tactTime: 2 },
        { nome: 'RACK RPD PA 2467', tactTime: 5 },
        { nome: 'RACK RPD PA 2867', tactTime: 4 },
        { nome: 'RACK RPD PA 3267', tactTime: 4 },
        { nome: 'RACK RPD PA 3667', tactTime: 3 },
        { nome: 'RACK RPD PA 4067', tactTime: 2 },
        { nome: 'RACK RPD PA 4467', tactTime: 2 },
        { nome: 'RACK RPD PP 4467', tactTime: 2 },
        { nome: 'RACK RPD PA 2487', tactTime: 3 },
        { nome: 'RACK RPD PA 2887', tactTime: 3 },
        { nome: 'RACK RPD PA 3287', tactTime: 2 },
        { nome: 'RACK RPD PA 3687', tactTime: 4 },
        { nome: 'RACK RPD PA 4087', tactTime: 3 },
        { nome: 'RACK RPD PA 4487', tactTime: 5 },
        { nome: 'RACK RPD PP 4487', tactTime: 2 },
        { nome: 'RACK RPD PA 3217', tactTime: 4 },
        { nome: 'RACK RPD PA 3617', tactTime: 2 },
        { nome: 'RACK RPD PA 4017', tactTime: 4 },
        { nome: 'RACK RPD PA 4417', tactTime: 3 },
        { nome: 'RACK RPD PP 4417', tactTime: 2 },
        { nome: 'ORG CABOS VERTICAL 36U', tactTime: 2 },
        { nome: 'ORG CABOS VERTICAL 44U', tactTime: 4 },
        { nome: 'RACK ESTRUTURA RPD-4495', tactTime: 4 },
        { nome: 'ENTERPRISE 44U (FECHADO)', tactTime: 2 },
        { nome: 'ENTERPRISE 44U (ABERTO)', tactTime: 3 },
        { nome: 'L 800', tactTime: 5 },
        { nome: 'L 600', tactTime: 2 },
        { nome: 'L 400', tactTime: 4 },
        { nome: 'L 290', tactTime: 4 },
        { nome: 'TELESC 800', tactTime: 3 },
        { nome: 'TELESC 600', tactTime: 2 },
        { nome: 'TELESC 400', tactTime: 2 },
        { nome: 'ALT 40', tactTime: 5 },
        { nome: 'ALT 80', tactTime: 4 },
        { nome: 'BAND CHANTELIER', tactTime: 4 },
        { nome: 'CONJUNTO FRENTE FALSA', tactTime: 4 },
        { nome: 'CONJUNTO FRENTE FALSA (5ND)', tactTime: 3 },
        { nome: 'RACK MRM 3U ', tactTime: 3 },
        { nome: 'RACK MRM 5U', tactTime: 6.25 },
        { nome: 'CAIXA ORG. PRETA', tactTime: 4.25 },
        { nome: 'CAIXA ORG. BRANCA', tactTime: 4.25 },
    ];

    // Objeto para gerenciar o estado sem localStorage
    let estadoAtual = {
        produtoAtivo: PRODUTOS[0].nome,
        // Textos padr√£o que ser√£o usados no in√≠cio
        textosPadrao: {
            caixaAzul: 'Ciclo iniciado',      // Padr√£o para In√≠cio de Ciclo (06:00:00, Retornos de Pausa)
            caixaRosa: 'Ciclo finalizado'     // Padr√£o para Fins de Ciclo (06:03:00, 06:06:00, etc)
        }
    };
    
    // -----------------------------------------------------------------------------------
    // FUN√á√ïES DE UTILIDADE DE TEMPO
    // -----------------------------------------------------------------------------------

    /** Converte "HH:MM:SS" para total de segundos. */
    function timeToSeconds(tempo) {
        const partes = tempo.split(':').map(Number);
        const h = partes[0] || 0;
        const m = partes[1] || 0;
        const s = partes[2] || 0;
        return h * 3600 + m * 60 + s;
    }

    /** Converte total de segundos para "HH:MM:SS". */
    function secondsToTime(totalSegundos) {
        const total = Math.round(totalSegundos);
        const segundos = total % 60;
        const minutos = Math.floor(total / 60) % 60;
        const horas = Math.floor(total / 3600);
        
        return [horas, minutos, segundos]
            .map(t => t.toString().padStart(2, '0'))
            .join(':');
    }

    /**
     * Adiciona minutos a um tempo, considerando o tempo residual ap√≥s os intervalos,
     * e garante que o turno termina em TURNO_FIM (17:30:00).
     */
    function adicionarMinutosComIntervalos(tempoInicial, minutosAdicionar) {
        let tempoSegundos = timeToSeconds(tempoInicial);
        let segundosRestantes = minutosAdicionar * 60;

        // La√ßo que conta o tempo produtivo segundo a segundo
        while (segundosRestantes > 0) {
            
            // Se o pr√≥ximo segundo j√° ultrapassa o fim do turno, encerra aqui.
            if (tempoSegundos + 1 > TURNO_FIM_SEGUNDOS) {
                return TURNO_FIM;
            }

            // Avan√ßa um segundo
            tempoSegundos++;
            
            let emIntervalo = false;
            
            // Verifica se o tempo atual caiu em algum intervalo de pausa
            for (const intervalo of INTERVALOS) {
                const inicioSegundos = timeToSeconds(intervalo.inicio);
                const fimSegundos = timeToSeconds(intervalo.fim);

                // Se o tempo est√° dentro do intervalo de pausa
                if (tempoSegundos > inicioSegundos && tempoSegundos <= fimSegundos) {
                    // Pula o tempo de descanso
                    tempoSegundos = fimSegundos;
                    emIntervalo = true;
                    break;
                }
            }
            
            // Se n√£o estamos em um intervalo, este foi um segundo produtivo
            if (!emIntervalo) {
                segundosRestantes--;
            }
        }
        
        // Retorna o tempo final. Se for maior que o fim do turno, retorna o fim do turno.
        return secondsToTime(Math.min(tempoSegundos, TURNO_FIM_SEGUNDOS));
    }
    
    // -----------------------------------------------------------------------------------
    // FUN√á√ïES DE GERA√á√ÉO E ATUALIZA√á√ÉO DO CONTE√öDO
    // -----------------------------------------------------------------------------------

    /**
     * Gera o HTML do conte√∫do de uma aba, exibindo todos os ciclos at√© 17:30:00.
     */
    function gerarConteudoAba(nomeProduto, tactTime) {
        let html = `
            <div class="tact-time-info">
                Produto Ativo: <strong>${nomeProduto}</strong> (Tact Time: ${tactTime} minutos)
            </div>
            <div class="caixas-extra">
                <div class="caixa-azul">
                    <label for="caixaAzul">Caixa Azul (Aviso de Ciclo INICIADO):</label>
                    <input type="text" id="caixaAzul" name="caixaAzul" placeholder="Ciclo iniciado" required>
                </div>
                <div class="caixa-rosa">
                    <label for="caixaRosa">Caixa Rosa (Aviso de Ciclo FINALIZADO):</label>
                    <input type="text" id="caixaRosa" name="caixaRosa" placeholder="Ciclo finalizado" required>
                </div>
            </div>
            <div class="intervalos">
                <h2>Intervalos Programados (Pausas)</h2>
                ${INTERVALOS.map((intervalo, index) => `
                    <div class="intervalo-box">
                        <label>${intervalo.nome} (In√≠cio/Fim):</label>
                        <input type="time" value="${intervalo.inicio.substring(0, 5)}" step="1" readonly>
                        <input type="time" value="${intervalo.fim.substring(0, 5)}" step="1" readonly>
                    </div>
                `).join('')}
            </div>
            <h2>Hor√°rios de Ciclo Calculados (At√© 17:30:00)</h2>
            <div class="caixas-rosa-multipla">
        `;

        let tempoAnterior = TURNO_INICIO;
        const limiteCiclos = 500; 
        const minutosTact = tactTime;

        for (let i = 1; i <= limiteCiclos; i++) {
            let tempoAtual = adicionarMinutosComIntervalos(tempoAnterior, minutosTact);

            if (tempoAtual === TURNO_FIM) {
                 html += `
                     <div>
                         <input type="time" id="hora_${nomeProduto}_${i}" value="${tempoAtual.substring(0, 8)}" step="1" readonly style="color: red; font-weight: bold;">
                     </div>
                 `;
                 break; 
            }
            

            html += `
                <div>
                    <input type="time" id="hora_${nomeProduto}_${i}" value="${tempoAtual.substring(0, 8)}" step="1" readonly>
                </div>
            `;
            
            tempoAnterior = tempoAtual;
        }

        html += `</div>`;
        return html;
    }


    /**
     * Alterna a aba ativa e carrega o conte√∫do, definindo os textos padr√µes nas caixas.
     */
    function trocarAba(novoProduto) {
        // Salva o texto digitado ANTES de trocar de aba, no objeto estadoAtual
        salvarEstadoTemporario();
        
        estadoAtual.produtoAtivo = novoProduto;

        document.querySelectorAll('.tab-button').forEach(btn => {
            btn.classList.remove('active');
            if (btn.dataset.produto === novoProduto) {
                btn.classList.add('active');
            }
        });

        const produtoData = PRODUTOS.find(p => p.nome === novoProduto);
        if (produtoData) {
            document.getElementById('product-content').innerHTML = gerarConteudoAba(produtoData.nome, produtoData.tactTime);
            // Carrega o texto salvo para a nova aba (ou o padr√£o, se for a primeira vez)
            carregarEstadoTemporario(novoProduto);
        }
    }
    
    // -----------------------------------------------------------------------------------
    // FUN√á√ïES DE PERSIST√äNCIA (TEMPOR√ÅRIA NA MEM√ìRIA) E REL√ìGIO
    // -----------------------------------------------------------------------------------
    
    // Armazena o texto digitado APENAS enquanto a p√°gina est√° aberta
    function salvarEstadoTemporario() {
        const caixaAzul = document.getElementById('caixaAzul');
        const caixaRosa = document.getElementById('caixaRosa');

        // Usa o nome do produto ativo como chave para salvar o texto digitado
        if (caixaAzul) estadoAtual[estadoAtual.produtoAtivo + '_azul'] = caixaAzul.value;
        if (caixaRosa) estadoAtual[estadoAtual.produtoAtivo + '_rosa'] = caixaRosa.value;
    }

    // Carrega o texto tempor√°rio ou define o padr√£o
    function carregarEstadoTemporario(chaveProduto) {
        const caixaAzul = document.getElementById('caixaAzul');
        const caixaRosa = document.getElementById('caixaRosa');
        
        // Verifica se h√° um texto salvo temporariamente para esta aba
        const textoAzulSalvo = estadoAtual[chaveProduto + '_azul'];
        const textoRosaSalvo = estadoAtual[chaveProduto + '_rosa'];

        // Define o texto na Caixa Azul
        if (caixaAzul) {
             // Prioridade: 1. Texto tempor√°rio salvo, 2. Texto padr√£o
             caixaAzul.value = textoAzulSalvo !== undefined ? textoAzulSalvo : estadoAtual.textosPadrao.caixaAzul;
        }
        
        // Define o texto na Caixa Rosa
        if (caixaRosa) {
             // Prioridade: 1. Texto tempor√°rio salvo, 2. Texto padr√£o
             caixaRosa.value = textoRosaSalvo !== undefined ? textoRosaSalvo : estadoAtual.textosPadrao.caixaRosa;
        }
        
        // Adiciona um listener para salvar o estado tempor√°rio sempre que o usu√°rio digitar
        if (caixaAzul) caixaAzul.addEventListener('input', salvarEstadoTemporario);
        if (caixaRosa) caixaRosa.addEventListener('input', salvarEstadoTemporario);
    }


    /**
     * Atualiza o rel√≥gio e verifica os hor√°rios de ciclo para avisos de voz.
     */
    function atualizarRelogio() {
        const now = new Date();
        const horarioBrasilia = [
            now.getHours().toString().padStart(2, '0'),
            now.getMinutes().toString().padStart(2, '0'),
            now.getSeconds().toString().padStart(2, '0')
        ].join(':');
        
        document.getElementById('relogio').textContent = horarioBrasilia;
        
        // Apenas verifica avisos de voz se o turno ainda n√£o acabou.
        if (timeToSeconds(horarioBrasilia) <= TURNO_FIM_SEGUNDOS) {
            if (sistemaIniciado) {
                verificarHorarioCaixas(horarioBrasilia, estadoAtual.produtoAtivo);
            }
        }
    }

    /**
     * Verifica se o hor√°rio do rel√≥gio coincide com algum hor√°rio de intervalo ou ciclo.
     */
    function verificarHorarioCaixas(horarioBrasilia, produto) {
        
        // 1. Verifica In√≠cio dos Intervalos (08:20:00, 11:30:00, 13:50:00) - PRIORIDADE M√ÅXIMA
        for (let i = 0; i < INTERVALOS.length; i++) {
            const inicioIntervalo = INTERVALOS[i].inicio;

            if (inicioIntervalo === horarioBrasilia) {
                // Dispara o aviso de voz espec√≠fico (Bom Caf√©/Almo√ßo)
                lerTextoEmVoz(INTERVALOS[i].avisoVoz); 
                return; 
            }
        }

        // 2. Prepara mensagens
        const caixaAzul = document.getElementById('caixaAzul');
        const caixaRosa = document.getElementById('caixaRosa');
        
        // Obt√©m o valor digitado ou usa o padr√£o tempor√°rio
        const mensagemCicloIniciado = caixaAzul ? caixaAzul.value : estadoAtual.textosPadrao.caixaAzul;
        const mensagemCicloFinalizado = caixaRosa ? caixaRosa.value : estadoAtual.textosPadrao.caixaRosa;


        // 3. Verifica IN√çCIO DE CICLO FIXO (06:00:00, 08:35:00, 12:30:00, 14:05:00)
        // Estes s√£o os hor√°rios de in√≠cio de turno e retorno das pausas.
        const horariosCicloIniciadoFixos = [
            TURNO_INICIO,   // 06:00:00 (In√≠cio do Turno)
            '08:35:00',     // (Retorno do Caf√© 1)
            '12:30:00',     // (Retorno do Almo√ßo)
            '14:05:00'      // (Retorno do Caf√© 2)
        ];
        
        if (horariosCicloIniciadoFixos.includes(horarioBrasilia)) {
            lerTextoEmVoz(mensagemCicloIniciado); // FALA: Ciclo iniciado
            return;
        }


        // 4. Verifica Hor√°rios de FIM DE CICLO CALCULADOS (Aviso Padr√£o da Caixa Rosa)
        const produtoData = PRODUTOS.find(p => p.nome === produto);
        if (produtoData) {
            const limiteCiclos = 500;
            
            for (let i = 1; i <= limiteCiclos; i++) {
                const horaCaixa = document.getElementById(`hora_${produto}_${i}`);
                
                if (horaCaixa && horaCaixa.value === horarioBrasilia) {
                    
                    // Dispara o aviso de FIM DE CICLO (Caixa Rosa)
                    lerTextoEmVoz(mensagemCicloFinalizado); // FALA: Ciclo finalizado
                    
                    // Aviso especial para o fim do turno (17:30:00)
                    if (horarioBrasilia === TURNO_FIM) {
                         lerTextoEmVoz("Turno finalizado √†s 17 horas e 30 minutos.");
                    }
                    return; 
                }
            }
        }
    }

    /**
     * Fun√ß√£o para ler o texto em voz alta.
     */
    function lerTextoEmVoz(texto) {
        if (texto.trim() !== "") {
            if (window.speechSynthesis.speaking) {
                window.speechSynthesis.cancel();
            }
            const utterance = new SpeechSynthesisUtterance(texto);
            utterance.lang = 'pt-BR';
            window.speechSynthesis.speak(utterance);
        }
    }
    
    // -----------------------------------------------------------------------------------
    // INICIALIZA√á√ÉO DO SISTEMA
    // -----------------------------------------------------------------------------------
    
    let sistemaIniciado = false;
    
    function iniciarSistema() {
        if (sistemaIniciado) return;
        sistemaIniciado = true;
        
        const botao = document.getElementById('iniciarSistema');
        
        if (botao) {
            botao.remove(); 
        }

        // Tenta ativar o Wake Lock assim que o usu√°rio clica no bot√£o "Iniciar Sistema"
        requestWakeLock(); 
        
        setInterval(atualizarRelogio, 1000);
        atualizarRelogio();

        lerTextoEmVoz("Sistema de avisos iniciado e ativado. Bom trabalho!");
    }

    function inicializar() {
        const tabsContainer = document.getElementById('tabs-container');
        
        // Configura as abas
        PRODUTOS.forEach(produto => {
            const button = document.createElement('button');
            button.className = 'tab-button';
            button.textContent = produto.nome;
            button.dataset.produto = produto.nome;
            button.onclick = () => trocarAba(produto.nome);
            tabsContainer.appendChild(button);
        });

        // Troca para a primeira aba (ou a que estava ativa na sess√£o)
        trocarAba(estadoAtual.produtoAtivo);

        // Adiciona listener ao bot√£o de in√≠cio
        const botaoIniciar = document.getElementById('iniciarSistema');
        if (botaoIniciar) {
            botaoIniciar.addEventListener('click', iniciarSistema);
        }
        
        atualizarRelogio();
        
        // Tenta ativar o Wake Lock no carregamento (√© crucial tentar na intera√ß√£o do bot√£o)
        requestWakeLock();
    }

    // Inicia tudo
    document.addEventListener('DOMContentLoaded', inicializar);

</script>

</body>

</html>
